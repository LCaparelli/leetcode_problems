/*
 * Group Anagrams
 *
 * Given an array of strings, group anagrams together.
 *
 * Example:
 *
 * Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
 * Output:
 * [
 * ["ate","eat","tea"],
 * ["nat","tan"],
 * ["bat"]
 * ]
 *
 * Note:
 *
 * All inputs will be in lowercase.
 * The order of your output does not matter.
 */

package week_1

var primesMap = map[byte]int{'a': 17, 'b': 41, 'c': 59, 'd': 97, 'e': 101, 'f': 7, 'g': 13, 'h': 19, 'i': 43, 'j': 61, 'k': 71,
	'l': 73, 'm': 2, 'n': 5, 'o': 11, 'p': 31, 'q': 37, 'r': 47, 's': 83, 't': 3, 'u': 29, 'v': 53,
	'w': 67, 'x': 79, 'y': 89, 'z': 23}

func groupAnagrams(strs []string) [][]string {

	buckets := make(map[int][]string)
	for _, str := range strs {
		product := primeProduct(str)
		if _, ok := buckets[product]; !ok {
			buckets[product] = []string{str}
		} else {
			buckets[product] = append(buckets[product], str)
		}
	}

	var ans [][]string
	for _, bucket := range buckets {
		ans = append(ans, bucket)
	}
	return ans
}

// I _think_ that the product of primes cannot be obtained by multiplying non-primes. Since each char is assigned a
// prime of its own then we shouldn't have collisions (or they would at least be very unlikely in case this isn't true).
// e.g., the number 30 can only be generated by the following primes: 2*3*5
func primeProduct(str string) int {
	ans := 1
	for _, char := range str {
		ans *= primesMap[byte(char)]
	}
	return ans
}
